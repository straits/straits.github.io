{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Straits Straits is an implementation of traits for JavaScript. It defines some conventions about traits and provides libraries to aid their usage, definition and implementation. Traits are a way to implement polymorphism: to extend objects and types with extra properties and behavior. Check out our introduction to understand what traits are, why we need them and how obtain them in JavaScript; or our quickstart to start playing with straits.","title":"Home"},{"location":"#straits","text":"Straits is an implementation of traits for JavaScript. It defines some conventions about traits and provides libraries to aid their usage, definition and implementation. Traits are a way to implement polymorphism: to extend objects and types with extra properties and behavior. Check out our introduction to understand what traits are, why we need them and how obtain them in JavaScript; or our quickstart to start playing with straits.","title":"Straits"},{"location":"faq/","text":"FAQ Status of Straits Straits is still experimental. It works reliably and it's proving itself very useful, but a few important features are still missing and major things (even the syntax for our statements) might be tweaked in the future. Symbol versioning Currently, if two different versions of a library that uses straits are used in the same project, all the symbols exposed by such library are duplicated. Let's consider a concrete example: scontainers . Let's say that the semantics of the flatten trait changes. The version of scontainers will be bumped, and new projects will start using the new version. Existing code might continue using the old one for a while. When both versions of scontainers are loaded in a project, two different full sets of traits will be created and coexist. The two versions of the same symbols (e.g. map , as well as flatten ) will both be implemented for the standard types. The containers you defined, instead, will only implement the version of the traits your code is using. Some other modules used in the project (the ones that use the other version of scontainers ) won't be able to use the container traits implemented on your objects. The current behavior could be ok, but a different behavior might be preferable. The traits whose semantics didn't change should use the same symbol even among two different versions of scontainers . Only the traits whose semantics changed should use different symbols (and thus different implementations). This requires somehow versioning the symbols. It's something that a library (e.g. scontainers ) could already do, but we believe that there should be a standard way and that straits.utils should offer an API to aid the effort. Trait set extensibility In most programming languages supporting traits (e.g. rust, haskell, go etc), one can automatically implement new traits for all the types that implement some other traits. This cannot be easily done in JavaScript, as it's a dynamic language and virtually anything can implement traits at any point of the execution. Keeping a database of which objects are implementing which trait is not only very resource consuming, but would also result in memory leaks. This feature would be very useful in JavaScript as well. Think of scontainers : a new trait whileEach could easily be implemented for every object that implements forEach . But how can we achieve that? As above, we need to choose a convention to extend traits, and straits.utils should offer aiding functions. use trait t from traitSet It might happen that two different trait sets expose traits with the same name. For instance straits.math.log is used to compute the logarithm function (i.e. Math.log ), while straits.console.log is used to print values to the console (i.e. console.log ). If your code wants to both use traits * from straits.math and use traits * from straits.console , .*log() can not currently be used. An advanced version of the use traits statement could help us here. Imagine the following piece of code: 1 2 3 4 import * as straits from 'straits' ; use traits * from straits . math ; use traits log , * from straits . console ; 7. * log (); It means that all the traits are imported both from straits.math and from straits.console , but we are going to use the log symbol from straits.console . Technical details How does straits scoping work? The .* operator looks for its right identifier in a different scope from the regular variable's scope. The scope it uses is populated by the use traits statements. The traits scopes have a visibility similar to regular scopes: they are valid only for the current block and all its nested ones. Traits used in inner scopes don't override those defined in outer scopes though, as shown in the following example: 1 2 3 4 5 6 7 8 9 10 11 const traits1 = { x : Symbol () }; use traits * from traits1 ; { const traits2 = { x : Symbol () }; use traits * from traits2 ; // Error! // Symbol x offered by multiple trait sets. []. * x ; } This is to avoid problems with API changes: imagine in fact that at the beginning of the development only traits1 defined the x trait. Code everywhere was written relying on that specific trait. If later during the development traits2 adds an x trait, the existing code should not start using that one, as the semantics may differ. Ideally it should be possible to explicitly say in which trait set to look for a trait: 1 2 3 4 5 6 7 8 9 const traits1 = { x : Symbol () }; use traits x , * from traits1 ; // `x` is only looked for in `traits1` { const traits2 = { x : Symbol () }; use traits * from traits2 ; []. * x ; // same as `[][traits1.x]` } @straits/babel does not implement this syntax yet. Common errors SyntaxError: Unexpected identifier; SyntaxError: Unexpected token * The use traits statement and .* operator aren't standard JavaScript. They're a proposed extension. Currently, the only way to use them is transpiling them to valid JavaScript using @straits/babel . No trait set is providing symbol \u2026 One of the traits accessed with the .* operator is not provided by any trait set: 1 2 3 4 const traitSet = {}; use traits * from traitSet ; []. * x ; Symbol \u2026 offered by multiple trait sets One of the traits accessed with the .* operator is provided by 2 or more trait sets: 1 2 3 4 5 6 const traitSet1 = { x : Symbol () }; const traitSet2 = { x : Symbol () }; use traits * from traitSet1 ; use traits * from traitSet2 ; []. * x ;","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#status-of-straits","text":"Straits is still experimental. It works reliably and it's proving itself very useful, but a few important features are still missing and major things (even the syntax for our statements) might be tweaked in the future.","title":"Status of Straits"},{"location":"faq/#symbol-versioning","text":"Currently, if two different versions of a library that uses straits are used in the same project, all the symbols exposed by such library are duplicated. Let's consider a concrete example: scontainers . Let's say that the semantics of the flatten trait changes. The version of scontainers will be bumped, and new projects will start using the new version. Existing code might continue using the old one for a while. When both versions of scontainers are loaded in a project, two different full sets of traits will be created and coexist. The two versions of the same symbols (e.g. map , as well as flatten ) will both be implemented for the standard types. The containers you defined, instead, will only implement the version of the traits your code is using. Some other modules used in the project (the ones that use the other version of scontainers ) won't be able to use the container traits implemented on your objects. The current behavior could be ok, but a different behavior might be preferable. The traits whose semantics didn't change should use the same symbol even among two different versions of scontainers . Only the traits whose semantics changed should use different symbols (and thus different implementations). This requires somehow versioning the symbols. It's something that a library (e.g. scontainers ) could already do, but we believe that there should be a standard way and that straits.utils should offer an API to aid the effort.","title":"Symbol versioning"},{"location":"faq/#trait-set-extensibility","text":"In most programming languages supporting traits (e.g. rust, haskell, go etc), one can automatically implement new traits for all the types that implement some other traits. This cannot be easily done in JavaScript, as it's a dynamic language and virtually anything can implement traits at any point of the execution. Keeping a database of which objects are implementing which trait is not only very resource consuming, but would also result in memory leaks. This feature would be very useful in JavaScript as well. Think of scontainers : a new trait whileEach could easily be implemented for every object that implements forEach . But how can we achieve that? As above, we need to choose a convention to extend traits, and straits.utils should offer aiding functions.","title":"Trait set extensibility"},{"location":"faq/#use-trait-t-from-traitset","text":"It might happen that two different trait sets expose traits with the same name. For instance straits.math.log is used to compute the logarithm function (i.e. Math.log ), while straits.console.log is used to print values to the console (i.e. console.log ). If your code wants to both use traits * from straits.math and use traits * from straits.console , .*log() can not currently be used. An advanced version of the use traits statement could help us here. Imagine the following piece of code: 1 2 3 4 import * as straits from 'straits' ; use traits * from straits . math ; use traits log , * from straits . console ; 7. * log (); It means that all the traits are imported both from straits.math and from straits.console , but we are going to use the log symbol from straits.console .","title":"use trait t from traitSet"},{"location":"faq/#technical-details","text":"","title":"Technical details"},{"location":"faq/#how-does-straits-scoping-work","text":"The .* operator looks for its right identifier in a different scope from the regular variable's scope. The scope it uses is populated by the use traits statements. The traits scopes have a visibility similar to regular scopes: they are valid only for the current block and all its nested ones. Traits used in inner scopes don't override those defined in outer scopes though, as shown in the following example: 1 2 3 4 5 6 7 8 9 10 11 const traits1 = { x : Symbol () }; use traits * from traits1 ; { const traits2 = { x : Symbol () }; use traits * from traits2 ; // Error! // Symbol x offered by multiple trait sets. []. * x ; } This is to avoid problems with API changes: imagine in fact that at the beginning of the development only traits1 defined the x trait. Code everywhere was written relying on that specific trait. If later during the development traits2 adds an x trait, the existing code should not start using that one, as the semantics may differ. Ideally it should be possible to explicitly say in which trait set to look for a trait: 1 2 3 4 5 6 7 8 9 const traits1 = { x : Symbol () }; use traits x , * from traits1 ; // `x` is only looked for in `traits1` { const traits2 = { x : Symbol () }; use traits * from traits2 ; []. * x ; // same as `[][traits1.x]` } @straits/babel does not implement this syntax yet.","title":"How does straits scoping work?"},{"location":"faq/#common-errors","text":"","title":"Common errors"},{"location":"faq/#syntaxerror-unexpected-identifier-syntaxerror-unexpected-token","text":"The use traits statement and .* operator aren't standard JavaScript. They're a proposed extension. Currently, the only way to use them is transpiling them to valid JavaScript using @straits/babel .","title":"SyntaxError: Unexpected identifier; SyntaxError: Unexpected token *"},{"location":"faq/#no-trait-set-is-providing-symbol","text":"One of the traits accessed with the .* operator is not provided by any trait set: 1 2 3 4 const traitSet = {}; use traits * from traitSet ; []. * x ;","title":"No trait set is providing symbol \u2026"},{"location":"faq/#symbol-offered-by-multiple-trait-sets","text":"One of the traits accessed with the .* operator is provided by 2 or more trait sets: 1 2 3 4 5 6 const traitSet1 = { x : Symbol () }; const traitSet2 = { x : Symbol () }; use traits * from traitSet1 ; use traits * from traitSet2 ; []. * x ;","title":"Symbol \u2026 offered by multiple trait sets"},{"location":"introduction/","text":"JavaScript traits Traits are a feature used by most modern languages to implement polymorphism without relying on inheritance. We'll introduce them, show which problems they would solve in JavaScript, and suggest a way to implement them. Hope you find it interesting! A few words about JavaScript and modern languages JavaScript has been my language of choice for the past 5 years in spite of its infamous quirks . It's fast to write, efficient to run, but above all else, it is modern . The language itself as well as its ecosystem uses great features and solutions, the best ones we know of. JavaScript supports Object Oriented Programming and uses duck typing to achieve polymorphism. This approach is more powerful and flexible than inheritance, but it still has some major flaws. A better, more modern way to implement OOP is using traits. Implementing decent traits in JavaScript through duck typing and prototypal inheritance used to have problems, but since a recent version of the language (ECMAScript 6) added a new primitive data type ( symbol ), the situation has improved. Very few are using this exciting feature of the language though, and that's what motivated this article. What are traits? Traits are a way to add semantics to existing types without risking unintentional interference with existing code. Traits are an alternative to inheritance as a method for implementing polymorphism , and all the modern languages have them: think of go, haskell and rust just to name a few. JavaScript is a prototypal , duck typed language, and this has always allowed programmers to do something very similar just by adding a new property to an existing prototype. But this simple addition has major problem and should be avoided. In fact you should never modify the prototype of types you don't own , and that's why most libraries go out of their way to offer new functionalities to existing types without actually modifying those types. Recent versions of JavaScript (i.e. ECMAScript 6) added a new primitive data type, symbol , which can be used to implement traits effectively [1] . A symbol is basically a unique identifier that can be used as a property and that will never collide with anything else. In ECMAScript 6 they needed a way to expand standard types without breaking compatibility with existing code. That is why they introduced symbol , and they're indeed using it to implement traits. However, instead of advertising this new feature and making traits a first class citizen, they have let symbol s remain in the shadows. The standard calls this feature protocol , instead of trait , and one of several examples is the iteration protocol . Besides the lack of guidelines and good examples, another issue makes it tough to use symbol s as traits: a lack of good syntax to do so. But enough talking! Let's look at an example. Why do we need traits? An example Imagine that you need a serializer to convert pieces of data into a string that can be stored somewhere. JSON.stringify() is not good enough, as it doesn't support \"complex\" objects (try to stringify a circular object, a RegExp , a Map etc, and you'll see). Well, let's write our own serialization function then. We want to support primitive data types ( boolean , number , string etc), built-in types ( Array , Map , RegExp etc), as well as the classes we or somebody else define. Something might be impossible to serialize, like Function s or Promise s, and that's OK: we'll just throw an error if we're given to serialize one of these. What we are trying to do, is to add a new serializing logic to most types, regardless of wether they're defined by us, by other people, or built-in in the language. This logic needs to be custom-written for each type. We can achieve that by adding a new serialize method to everything. This way var.serialize() will return a serializable representation for any variable var . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // for some primitive data types `JSON.stringify()` works just fine: Boolean . prototype . serialize = Number . prototype . serialize = String . prototype . serialize = function () { return JSON . stringify ( this ); }; // implementing `serialize` for some bult-in types RegExp . prototype . serialize = function () { return `/ ${ this . source } / ${ this . flags } ` ; }; Array . prototype . serialize = function () { const values = this . map ( ( item )=> item . serialize () ). join ( `, ` ); return `[ ${ values } ]` ; }; Object . prototype . serialize = function () { const properties = Object . entries ( this ). map ( ([ key , value ])=> ` ${ key . serialize () } : ${ value . serialize () } ` ); return `{ ${ properties } }` ; }; // implementing it for our custom types as well... class Person { constructor ( name , age ) { this . name = name ; this . age = age ; this . objects = []; } // ... serialize () { return `Person( ${ this . name . serialize () } , ${ this . age . serialize () } ){` + `objects: ${ this . objects . serialize () } ` + `}` ; } } Let's try it out... 1 2 3 const peoro = new Person ( \"peoro\" , 32 ); peoro . objects . push ({ a : true , re : /^...$/g }); console . log ( peoro . serialize () ); It prints: 1 Person(\"peoro\", 32){objects:[{\"a\": true,\"re\": /^...$/g}]} Which is exactly what we wanted. Amazing! Isn't it? Well, not really. We modified existing types we have no ownership of. That's called monkey patching . It seems to work, but will give many serious problems as soon as somebody tries to use our serializer in a real application. Let's see a few: Try to serialize the object {serialize:true} : you'll get an error, since the serialize property of such object overrides Object.prototype.serialize . Somebody else might define a different serialize method to serialize objects in a different format. Our serializer and theirs will be incompatible; if both are loaded in the same project (even as an indirect dependency) things will break in unexpected ways. Try to iterate using for...in on a plain object: you'll iterate over the Object.prototype 's serialize property as well. This is gonna break the majority of existing code. The problem with monkey patching is that we're modifying global data: any function that wasn't written by us might rely on assumptions on existing objects that we might have broken, This is the reason why libraries (including the huge ones that could impose their own standards - think of jQuery or lodash) won't modify built-in types. They would rather expose free functions (like lodash), or wrappers to encapsulate existing objects and add new methods only to their wrappers (like jQuery). It's important to note that the solutions chosen by these libraries are quite limited: it's hard to specialize the behavior for wrappers and free functions. When you write them, you might hardcode a waterfall of if s to support a bunch of types, but later it cannot be extended. You won't be able to make their functions work with your custom types. As an exercise, try to define a serialize function able to serialize several types without modifying existing objects nor their prototype. Then try to make it possible for the users of your library to add support for their own types, or to existing third-party objects. Most of the solutions you might consider (e.g. using a Type \u2192 serializationFunction map) would likely result in further unexpected problems. This is where symbol s come in our assistance. Welcome to the world of traits. How to implement traits in JavaScript A symbol is a primitive type introduced in ES6 which can be used as an object's key, and it's guaranteed to never ever clash with anything else: if sym is a symbol , the only way to access object[sym] is by using sym itself. Besides, for...in loops won't iterate over symbol s. It's not a coincidence that symbol s work this way: they were added to the standard for the exact same reason why we need them. ECMAScript 6 wanted to add new functionalities to existing types, but, as we've seen, it was impossible to do so without risking to break existing code. For an example of how the standard is using them, look at the iterable protocol . A new symbol Symbol.iterator was introduced. The types that implement it can be iterated over using the for...of syntax . Such symbol is implemented for Array , TypedArray , String , Map , Set , and you can implement it on your own types as well. Our serializer should instantiate a serialize symbol, use it, and expose it for everybody to use: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const serialize = Symbol (); Boolean . prototype [ serialize ] = Number . prototype [ serialize ] = String . prototype [ serialize ] = function () { /*...*/ }; RegExp . prototype [ serialize ] = function () { /*...*/ }; Array . prototype [ serialize ] = function () { /*...*/ }; Object . prototype [ serialize ] = function () { /*...*/ }; class Person { // ... [ serialize ]() { // ... } } module . exports = { Person , serialize , }; Our users can then implement the same serialize symbol on their types and use it. No other existing piece of code will be affected. symbol s aren't the final answer though... They're very powerful and are used by the standard to implement traits, but the amount of documentation covering them is miniscule. Virtually no guidelines, very few tutorials or articles explaining what they are and how to use them. The result is that very few modules are using them. A further problem concerns their syntax: there's no special syntax to use them, and in some cases this becomes a pain. Imagine a lodash-traits library that offers and implement a symbol for each lodash function. You wouldn't be able to just do: 1 2 3 4 5 6 require ( 'lodash-traits' ); // returning an object's values (numbers), sorted and without duplicates return object // { a:7, b:12, c:4, d:7, e:1 } . values () // [7, 12, 4, 7, 1] . sortBy () // [1, 4, 7, 7, 12] . uniq () // [1, 4, 7, 12] You'd have to do... 1 2 3 4 5 6 const _ = require ( 'lodash-traits' ); // returning an object's values (numbers), sorted and without duplicates return object // { a:7, b:12, c:4, d:7, e:1 } [ _ . values ]() // [7, 12, 4, 7, 1] [ _ . sortBy ]() // [1, 4, 7, 7, 12] [ _ . uniq ]() // [1, 4, 7, 12] And this becomes uncomfortable pretty fast. This is why, in addition to traits, we're proposing a new syntax, designed to aid trait development. A better syntax for traits We're proposing a language extension, the straits syntax , to be able to write the previous snippet the following way: 1 2 3 4 5 6 use traits * from require ( 'lodash-traits' ); // returning an object's values (numbers), sorted and without duplicates return object // { a:7, b:12, c:4, d:7, e:1 } . * values () // [7, 12, 4, 7, 1] . * sortBy () // [1, 4, 7, 7, 12] . * uniq () // [1, 4, 7, 12] What does it mean? use traits * from traitSet; means that we will be looking for symbols inside the object traitSet . We call traitSet a trait set . object.*key means that we're accessing object with the symbol called key found in the trait set in use. In pratice: 1 2 use traits * from traitSet ; object . * key Is roughly equivalent to: 1 object [ traitSet . key ] We would write the serialization part of our module the following way: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const traits = { serialize : Symbol () }; // enabling .* for our traits use traits * from traits ; // implementing .*serialize() for `Number` Number . prototype . * serialize = function () { return this . toString (); }; // ... // using .*serialize() const value = 7 ; value . * serialize (); // \"7\" This syntax is compatible with the standard symbol s built-in in ECMAScript 6: 1 2 3 4 use traits * from Symbol ; // this is `[][Symbol.iterator]` []. * iterator It's possible to use traits from multiple trait sets at the same time, and we'll receive an error in case a trait is duplicated or missing. This syntax is meant to... Turn symbol s into first class citizens of JavaScript. Make traits easier both to declare and use. Avoid conflicts and mistakes between variables in scope and traits. It's currently possible to develop code using this syntax, and to convert it into standard JavaScript using a babel plugin: straits-babel . Article conclusion and straits introduction Hopefully it's now clear why there's a need for traits, how to create them using symbol s, prototypal inheritance and duck typing, and how to use them comfortably. The straits project offers a number of common functions to aid in the declaration and usage of symbol s, traits and trait sets. If you want to give it a chance, just run npm init @straits in an empty directory: it will set up a project ready to use the new syntax. Then run npm install and everything will be ready: npm start will run src/index.js , a hello-world ready to be played with. If you like traits, you to just use the straits syntax in your project. It will be completely transparent to your users, since the code you'll release or publish on npm will be transpiled: standard, regular JavaScript. The users of your module are free to choose whether they want to use use this syntax as well, or rather use symbol s manually or even through free-functions. Give a look at lodash-traits' test/index.js to see how a module using traits can be used with or without using the straits syntax. If you want to give a look at some projects relying on traits, check out: lodash-traits : a trait set wrapping lodash functions. chalk-traits : a trait set wrapping chalk functions. Scontainers : a powerful, high performance library (although still in alpha) to work with collections of data. ESAST : a library to manipulate JavaScript AST in a comfortable way (i.e. without wrapper objects). 1: Alternatively, WeakMap could be used to implement traits. WeakMap was introduced in ECMAScript 6 as well, and we decided against it since the standard uses symbol s to implement traits.","title":"Introduction"},{"location":"introduction/#javascript-traits","text":"Traits are a feature used by most modern languages to implement polymorphism without relying on inheritance. We'll introduce them, show which problems they would solve in JavaScript, and suggest a way to implement them. Hope you find it interesting!","title":"JavaScript traits"},{"location":"introduction/#a-few-words-about-javascript-and-modern-languages","text":"JavaScript has been my language of choice for the past 5 years in spite of its infamous quirks . It's fast to write, efficient to run, but above all else, it is modern . The language itself as well as its ecosystem uses great features and solutions, the best ones we know of. JavaScript supports Object Oriented Programming and uses duck typing to achieve polymorphism. This approach is more powerful and flexible than inheritance, but it still has some major flaws. A better, more modern way to implement OOP is using traits. Implementing decent traits in JavaScript through duck typing and prototypal inheritance used to have problems, but since a recent version of the language (ECMAScript 6) added a new primitive data type ( symbol ), the situation has improved. Very few are using this exciting feature of the language though, and that's what motivated this article.","title":"A few words about JavaScript and modern languages"},{"location":"introduction/#what-are-traits","text":"Traits are a way to add semantics to existing types without risking unintentional interference with existing code. Traits are an alternative to inheritance as a method for implementing polymorphism , and all the modern languages have them: think of go, haskell and rust just to name a few. JavaScript is a prototypal , duck typed language, and this has always allowed programmers to do something very similar just by adding a new property to an existing prototype. But this simple addition has major problem and should be avoided. In fact you should never modify the prototype of types you don't own , and that's why most libraries go out of their way to offer new functionalities to existing types without actually modifying those types. Recent versions of JavaScript (i.e. ECMAScript 6) added a new primitive data type, symbol , which can be used to implement traits effectively [1] . A symbol is basically a unique identifier that can be used as a property and that will never collide with anything else. In ECMAScript 6 they needed a way to expand standard types without breaking compatibility with existing code. That is why they introduced symbol , and they're indeed using it to implement traits. However, instead of advertising this new feature and making traits a first class citizen, they have let symbol s remain in the shadows. The standard calls this feature protocol , instead of trait , and one of several examples is the iteration protocol . Besides the lack of guidelines and good examples, another issue makes it tough to use symbol s as traits: a lack of good syntax to do so. But enough talking! Let's look at an example.","title":"What are traits?"},{"location":"introduction/#why-do-we-need-traits-an-example","text":"Imagine that you need a serializer to convert pieces of data into a string that can be stored somewhere. JSON.stringify() is not good enough, as it doesn't support \"complex\" objects (try to stringify a circular object, a RegExp , a Map etc, and you'll see). Well, let's write our own serialization function then. We want to support primitive data types ( boolean , number , string etc), built-in types ( Array , Map , RegExp etc), as well as the classes we or somebody else define. Something might be impossible to serialize, like Function s or Promise s, and that's OK: we'll just throw an error if we're given to serialize one of these. What we are trying to do, is to add a new serializing logic to most types, regardless of wether they're defined by us, by other people, or built-in in the language. This logic needs to be custom-written for each type. We can achieve that by adding a new serialize method to everything. This way var.serialize() will return a serializable representation for any variable var . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // for some primitive data types `JSON.stringify()` works just fine: Boolean . prototype . serialize = Number . prototype . serialize = String . prototype . serialize = function () { return JSON . stringify ( this ); }; // implementing `serialize` for some bult-in types RegExp . prototype . serialize = function () { return `/ ${ this . source } / ${ this . flags } ` ; }; Array . prototype . serialize = function () { const values = this . map ( ( item )=> item . serialize () ). join ( `, ` ); return `[ ${ values } ]` ; }; Object . prototype . serialize = function () { const properties = Object . entries ( this ). map ( ([ key , value ])=> ` ${ key . serialize () } : ${ value . serialize () } ` ); return `{ ${ properties } }` ; }; // implementing it for our custom types as well... class Person { constructor ( name , age ) { this . name = name ; this . age = age ; this . objects = []; } // ... serialize () { return `Person( ${ this . name . serialize () } , ${ this . age . serialize () } ){` + `objects: ${ this . objects . serialize () } ` + `}` ; } } Let's try it out... 1 2 3 const peoro = new Person ( \"peoro\" , 32 ); peoro . objects . push ({ a : true , re : /^...$/g }); console . log ( peoro . serialize () ); It prints: 1 Person(\"peoro\", 32){objects:[{\"a\": true,\"re\": /^...$/g}]} Which is exactly what we wanted. Amazing! Isn't it? Well, not really. We modified existing types we have no ownership of. That's called monkey patching . It seems to work, but will give many serious problems as soon as somebody tries to use our serializer in a real application. Let's see a few: Try to serialize the object {serialize:true} : you'll get an error, since the serialize property of such object overrides Object.prototype.serialize . Somebody else might define a different serialize method to serialize objects in a different format. Our serializer and theirs will be incompatible; if both are loaded in the same project (even as an indirect dependency) things will break in unexpected ways. Try to iterate using for...in on a plain object: you'll iterate over the Object.prototype 's serialize property as well. This is gonna break the majority of existing code. The problem with monkey patching is that we're modifying global data: any function that wasn't written by us might rely on assumptions on existing objects that we might have broken, This is the reason why libraries (including the huge ones that could impose their own standards - think of jQuery or lodash) won't modify built-in types. They would rather expose free functions (like lodash), or wrappers to encapsulate existing objects and add new methods only to their wrappers (like jQuery). It's important to note that the solutions chosen by these libraries are quite limited: it's hard to specialize the behavior for wrappers and free functions. When you write them, you might hardcode a waterfall of if s to support a bunch of types, but later it cannot be extended. You won't be able to make their functions work with your custom types. As an exercise, try to define a serialize function able to serialize several types without modifying existing objects nor their prototype. Then try to make it possible for the users of your library to add support for their own types, or to existing third-party objects. Most of the solutions you might consider (e.g. using a Type \u2192 serializationFunction map) would likely result in further unexpected problems. This is where symbol s come in our assistance. Welcome to the world of traits.","title":"Why do we need traits? An example"},{"location":"introduction/#how-to-implement-traits-in-javascript","text":"A symbol is a primitive type introduced in ES6 which can be used as an object's key, and it's guaranteed to never ever clash with anything else: if sym is a symbol , the only way to access object[sym] is by using sym itself. Besides, for...in loops won't iterate over symbol s. It's not a coincidence that symbol s work this way: they were added to the standard for the exact same reason why we need them. ECMAScript 6 wanted to add new functionalities to existing types, but, as we've seen, it was impossible to do so without risking to break existing code. For an example of how the standard is using them, look at the iterable protocol . A new symbol Symbol.iterator was introduced. The types that implement it can be iterated over using the for...of syntax . Such symbol is implemented for Array , TypedArray , String , Map , Set , and you can implement it on your own types as well. Our serializer should instantiate a serialize symbol, use it, and expose it for everybody to use: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const serialize = Symbol (); Boolean . prototype [ serialize ] = Number . prototype [ serialize ] = String . prototype [ serialize ] = function () { /*...*/ }; RegExp . prototype [ serialize ] = function () { /*...*/ }; Array . prototype [ serialize ] = function () { /*...*/ }; Object . prototype [ serialize ] = function () { /*...*/ }; class Person { // ... [ serialize ]() { // ... } } module . exports = { Person , serialize , }; Our users can then implement the same serialize symbol on their types and use it. No other existing piece of code will be affected. symbol s aren't the final answer though... They're very powerful and are used by the standard to implement traits, but the amount of documentation covering them is miniscule. Virtually no guidelines, very few tutorials or articles explaining what they are and how to use them. The result is that very few modules are using them. A further problem concerns their syntax: there's no special syntax to use them, and in some cases this becomes a pain. Imagine a lodash-traits library that offers and implement a symbol for each lodash function. You wouldn't be able to just do: 1 2 3 4 5 6 require ( 'lodash-traits' ); // returning an object's values (numbers), sorted and without duplicates return object // { a:7, b:12, c:4, d:7, e:1 } . values () // [7, 12, 4, 7, 1] . sortBy () // [1, 4, 7, 7, 12] . uniq () // [1, 4, 7, 12] You'd have to do... 1 2 3 4 5 6 const _ = require ( 'lodash-traits' ); // returning an object's values (numbers), sorted and without duplicates return object // { a:7, b:12, c:4, d:7, e:1 } [ _ . values ]() // [7, 12, 4, 7, 1] [ _ . sortBy ]() // [1, 4, 7, 7, 12] [ _ . uniq ]() // [1, 4, 7, 12] And this becomes uncomfortable pretty fast. This is why, in addition to traits, we're proposing a new syntax, designed to aid trait development.","title":"How to implement traits in JavaScript"},{"location":"introduction/#a-better-syntax-for-traits","text":"We're proposing a language extension, the straits syntax , to be able to write the previous snippet the following way: 1 2 3 4 5 6 use traits * from require ( 'lodash-traits' ); // returning an object's values (numbers), sorted and without duplicates return object // { a:7, b:12, c:4, d:7, e:1 } . * values () // [7, 12, 4, 7, 1] . * sortBy () // [1, 4, 7, 7, 12] . * uniq () // [1, 4, 7, 12] What does it mean? use traits * from traitSet; means that we will be looking for symbols inside the object traitSet . We call traitSet a trait set . object.*key means that we're accessing object with the symbol called key found in the trait set in use. In pratice: 1 2 use traits * from traitSet ; object . * key Is roughly equivalent to: 1 object [ traitSet . key ] We would write the serialization part of our module the following way: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const traits = { serialize : Symbol () }; // enabling .* for our traits use traits * from traits ; // implementing .*serialize() for `Number` Number . prototype . * serialize = function () { return this . toString (); }; // ... // using .*serialize() const value = 7 ; value . * serialize (); // \"7\" This syntax is compatible with the standard symbol s built-in in ECMAScript 6: 1 2 3 4 use traits * from Symbol ; // this is `[][Symbol.iterator]` []. * iterator It's possible to use traits from multiple trait sets at the same time, and we'll receive an error in case a trait is duplicated or missing. This syntax is meant to... Turn symbol s into first class citizens of JavaScript. Make traits easier both to declare and use. Avoid conflicts and mistakes between variables in scope and traits. It's currently possible to develop code using this syntax, and to convert it into standard JavaScript using a babel plugin: straits-babel .","title":"A better syntax for traits"},{"location":"introduction/#article-conclusion-and-straits-introduction","text":"Hopefully it's now clear why there's a need for traits, how to create them using symbol s, prototypal inheritance and duck typing, and how to use them comfortably. The straits project offers a number of common functions to aid in the declaration and usage of symbol s, traits and trait sets. If you want to give it a chance, just run npm init @straits in an empty directory: it will set up a project ready to use the new syntax. Then run npm install and everything will be ready: npm start will run src/index.js , a hello-world ready to be played with. If you like traits, you to just use the straits syntax in your project. It will be completely transparent to your users, since the code you'll release or publish on npm will be transpiled: standard, regular JavaScript. The users of your module are free to choose whether they want to use use this syntax as well, or rather use symbol s manually or even through free-functions. Give a look at lodash-traits' test/index.js to see how a module using traits can be used with or without using the straits syntax. If you want to give a look at some projects relying on traits, check out: lodash-traits : a trait set wrapping lodash functions. chalk-traits : a trait set wrapping chalk functions. Scontainers : a powerful, high performance library (although still in alpha) to work with collections of data. ESAST : a library to manipulate JavaScript AST in a comfortable way (i.e. without wrapper objects). 1: Alternatively, WeakMap could be used to implement traits. WeakMap was introduced in ECMAScript 6 as well, and we decided against it since the standard uses symbol s to implement traits.","title":"Article conclusion and straits introduction"},{"location":"quickstart/","text":"Quickstart Straits syntax setup If you wish to use the straits syntax , create a new folder and run npm init @straits in there. This will lead you through the setup of a new Node project ready to use the custom syntax. Once the project has been set up, run npm install to install the dependencies, then: npm start , to run an example hello-world script. npm test , to run the mocha test suite for the example hello-world. npm run prepare to transpile your code using the straits syntax into standard JavaScript. The generated code will be placed in dist/ . The prepare npm script is automatically executed both by npm install and npm publish : there's no risk to forget transpiling your code. Now modify src/index.js to start implementing your own logic. Using traits It's possible to use traits using three different styles: Using the straits syntax : the most performant and simplest way. Using traits as member symbols . Using traits as free functions . Let's take lodash-traits as an example. Straits syntax The simplest and most performant way to use traits is by using the .* operator and use traits statement. For more details, refer to @straits/babel . 1 2 3 4 5 6 7 8 9 10 11 12 const lodashTraits = require ( 'lodash-traits' ); // enabling `.*` for `lodashTraits` symbols use traits * from lodashTraits ; const result = [[ 1 ], 7 ,[ - 2 , 5 ], 2 , 7 ,[], 4 ] . * flatten () // [1, 7, -2, 5, 2, 7, 4] . * reverse () // [4, 7, 2, 5, -2, 7, 1] . * filter ( item => item % 2 !== 0 ) // [7, 5, 7, 1] . * map ( item => item ** 2 ) // [49, 25, 49, 1] . * sum (); // result: 124 Traits as member symbols It's possible to use traits directly, as they're just symbol s. Code written this way will offer the same performance as the .* syntax. Be careful when assigning traits this way: assigning the trait directly (i.e. obj[trait] = value; ) will result in the trait being enumerable. One should use Object.defineProperty(obj, trait, {value:value, configurable:true}); instead; that's what happens when obj.*trait = value; is evaluated. The latest example from above could look like this: 1 2 3 4 5 6 7 8 9 const lodashTraits = require ( 'lodash-traits' ); const result = [[ 1 ], 7 ,[ - 2 , 5 ], 2 , 7 ,[], 4 ]; [ lodashTraits . flatten ]() // [1, 7, -2, 5, 2, 7, 4] [ lodashTraits . reverse ]() // [4, 7, 2, 5, -2, 7, 1] [ lodashTraits . filter ]( item => item % 2 !== 0 ) // [7, 5, 7, 1] [ lodashTraits . map ]( item => item ** 2 ) // [49, 25, 49, 1] [ lodashTraits . sum ](); // result: 124 Traits as free functions It's possible to create free functions that wrap traits. This could introduce a small overhead, as the free function is an indirection, but it has the advantage of working with null and undefined . The @straits/utils module offers functions to generate free functions from traits. Trait sets defined with TraitSet from @straits/utils already have an .asFreeFunctions() method to obtain a set of free functions from a trait set. Here is once again the above example written using this approach: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const lodashTraits = require ( 'lodash-traits' ); // `_` is pretty much the same as the official `lodash` const _ = scontainers . asFreeFunctions (); const result = _ . sum ( _ . map ( _ . filter ( _ . reverse ( _ . flatten ( [[ 1 ], 7 ,[ - 2 , 5 ], 2 , 7 ,[], 4 ] ) // [1, 7, -2, 5, 2, 7, 4] ), // [4, 7, 2, 5, -2, 7, 1] item => item % 2 !== 0 ), // [7, 5, 7, 1] item => item ** 2 ) // [49, 25, 49, 1] ); // result: 124 If you need to work with a trait set without an .asFreeFunctions() method (e.g. the global Well-known symbols ), you can do: 1 2 3 4 5 6 7 const { TraitSet } = require ( '@straits/utils' ); const fns = Symbol [ TraitSet . traitsToFreeFunctions ](); const d = new Date (); console . log ( d . * toPrimitive ( 'number' ) ); // current timestamp console . log ( d . * toPrimitive ( 'string' ) ); // current date as a string Implementing traits Traits can be implemented using: the straits syntax: 1 2 3 const obj = {}; use traits * from Symbol ; obj . * toPrimitive = function ( hint ) { /*...*/ }; some @straits/utils functions: 1 2 3 const obj = {}; use traits * from require ( '@straits/utils' ). TraitSet ; Symbol . toPrimitive . * impl ( obj , function ( hint ){ /*...*/ } ); Object.defineProperty : 1 2 3 4 const obj = {}; Object . defineProperty ( obj , Symbol . toPrimitive , { configurable : true , value : function (){ /*...*/ } }); We discourage from assing member symbols directly, as they will end up being enumerable. 1 2 3 const obj = {}; // do NOT do this! obj [ Symbol . toPrimitive ] = function ( hint ) { /*...*/ }; Defining new trait sets We recommend to use @straits/utils to define new trait sets. 1 2 3 4 5 6 7 8 9 10 11 const { TraitSet } = require ( '@straits/utils' ); const traitSet1 = new TraitSet ({ x : Symbol (), y : Symbol (), }); // or const traitSet2 = TraitSet . fromStrings ([ `x` , `y` , ]); This way, the trait set will have a .asFreeFunctions() method.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#straits-syntax-setup","text":"If you wish to use the straits syntax , create a new folder and run npm init @straits in there. This will lead you through the setup of a new Node project ready to use the custom syntax. Once the project has been set up, run npm install to install the dependencies, then: npm start , to run an example hello-world script. npm test , to run the mocha test suite for the example hello-world. npm run prepare to transpile your code using the straits syntax into standard JavaScript. The generated code will be placed in dist/ . The prepare npm script is automatically executed both by npm install and npm publish : there's no risk to forget transpiling your code. Now modify src/index.js to start implementing your own logic.","title":"Straits syntax setup"},{"location":"quickstart/#using-traits","text":"It's possible to use traits using three different styles: Using the straits syntax : the most performant and simplest way. Using traits as member symbols . Using traits as free functions . Let's take lodash-traits as an example.","title":"Using traits"},{"location":"quickstart/#straits-syntax","text":"The simplest and most performant way to use traits is by using the .* operator and use traits statement. For more details, refer to @straits/babel . 1 2 3 4 5 6 7 8 9 10 11 12 const lodashTraits = require ( 'lodash-traits' ); // enabling `.*` for `lodashTraits` symbols use traits * from lodashTraits ; const result = [[ 1 ], 7 ,[ - 2 , 5 ], 2 , 7 ,[], 4 ] . * flatten () // [1, 7, -2, 5, 2, 7, 4] . * reverse () // [4, 7, 2, 5, -2, 7, 1] . * filter ( item => item % 2 !== 0 ) // [7, 5, 7, 1] . * map ( item => item ** 2 ) // [49, 25, 49, 1] . * sum (); // result: 124","title":"Straits syntax"},{"location":"quickstart/#traits-as-member-symbols","text":"It's possible to use traits directly, as they're just symbol s. Code written this way will offer the same performance as the .* syntax. Be careful when assigning traits this way: assigning the trait directly (i.e. obj[trait] = value; ) will result in the trait being enumerable. One should use Object.defineProperty(obj, trait, {value:value, configurable:true}); instead; that's what happens when obj.*trait = value; is evaluated. The latest example from above could look like this: 1 2 3 4 5 6 7 8 9 const lodashTraits = require ( 'lodash-traits' ); const result = [[ 1 ], 7 ,[ - 2 , 5 ], 2 , 7 ,[], 4 ]; [ lodashTraits . flatten ]() // [1, 7, -2, 5, 2, 7, 4] [ lodashTraits . reverse ]() // [4, 7, 2, 5, -2, 7, 1] [ lodashTraits . filter ]( item => item % 2 !== 0 ) // [7, 5, 7, 1] [ lodashTraits . map ]( item => item ** 2 ) // [49, 25, 49, 1] [ lodashTraits . sum ](); // result: 124","title":"Traits as member symbols"},{"location":"quickstart/#traits-as-free-functions","text":"It's possible to create free functions that wrap traits. This could introduce a small overhead, as the free function is an indirection, but it has the advantage of working with null and undefined . The @straits/utils module offers functions to generate free functions from traits. Trait sets defined with TraitSet from @straits/utils already have an .asFreeFunctions() method to obtain a set of free functions from a trait set. Here is once again the above example written using this approach: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const lodashTraits = require ( 'lodash-traits' ); // `_` is pretty much the same as the official `lodash` const _ = scontainers . asFreeFunctions (); const result = _ . sum ( _ . map ( _ . filter ( _ . reverse ( _ . flatten ( [[ 1 ], 7 ,[ - 2 , 5 ], 2 , 7 ,[], 4 ] ) // [1, 7, -2, 5, 2, 7, 4] ), // [4, 7, 2, 5, -2, 7, 1] item => item % 2 !== 0 ), // [7, 5, 7, 1] item => item ** 2 ) // [49, 25, 49, 1] ); // result: 124 If you need to work with a trait set without an .asFreeFunctions() method (e.g. the global Well-known symbols ), you can do: 1 2 3 4 5 6 7 const { TraitSet } = require ( '@straits/utils' ); const fns = Symbol [ TraitSet . traitsToFreeFunctions ](); const d = new Date (); console . log ( d . * toPrimitive ( 'number' ) ); // current timestamp console . log ( d . * toPrimitive ( 'string' ) ); // current date as a string","title":"Traits as free functions"},{"location":"quickstart/#implementing-traits","text":"Traits can be implemented using: the straits syntax: 1 2 3 const obj = {}; use traits * from Symbol ; obj . * toPrimitive = function ( hint ) { /*...*/ }; some @straits/utils functions: 1 2 3 const obj = {}; use traits * from require ( '@straits/utils' ). TraitSet ; Symbol . toPrimitive . * impl ( obj , function ( hint ){ /*...*/ } ); Object.defineProperty : 1 2 3 4 const obj = {}; Object . defineProperty ( obj , Symbol . toPrimitive , { configurable : true , value : function (){ /*...*/ } }); We discourage from assing member symbols directly, as they will end up being enumerable. 1 2 3 const obj = {}; // do NOT do this! obj [ Symbol . toPrimitive ] = function ( hint ) { /*...*/ };","title":"Implementing traits"},{"location":"quickstart/#defining-new-trait-sets","text":"We recommend to use @straits/utils to define new trait sets. 1 2 3 4 5 6 7 8 9 10 11 const { TraitSet } = require ( '@straits/utils' ); const traitSet1 = new TraitSet ({ x : Symbol (), y : Symbol (), }); // or const traitSet2 = TraitSet . fromStrings ([ `x` , `y` , ]); This way, the trait set will have a .asFreeFunctions() method.","title":"Defining new trait sets"},{"location":"syntax/","text":"Straits syntax Straits introduces the .* operator and use traits statement. use traits statement 1 use traits * from traitSet ; The use traits statement is used to specify which traits are available. use traits * from traitSet; enables all the traits defined in traitSet . It applies to the current scopes and all subscopes. .* operator 1 2 obj . * trait obj . * trait = ...; The .* operator is used to access a trait of an object. obj.*trait will access the trait named trait on obj . Exactly one trait named trait must be available (thanks to an use traits statement) in the scope where it's used: if none, or multiple different ones are available, an exception will be thrown. If .* is used to assign a trait, such trait (i.e. symbol property) will be not-enumerable. .* requires a trait name to be statically used. A symbol variable cannot be used as a trait: it can be accessed using [] . .* won't work on null or undefined , since . operator can't work on them either. @straits/utils offers some utility function to work with them: an asFreeFunction() function to obtain a free function wrapping a trait. Such free function could have a default behavior for objects that don't implement the trait, which can be installed with implDefault() . @straits/babel @straits/babel can be used to transpile the traits syntax into standard JavaScript. Proposed enhancements Use specific traits The use traits statement could support, besides * , a list of trait names: 1 2 use traits x , y from traitSet1 ; use traits z , * from traitSet2 ; This would cause looking for the explicitly listed traits in specific trait sets with higher priority: if different traits with the same name were enabled by some use traits * statements, those would be ignored and no error would be thrown. @straits/babel doesn't support such syntax yet. .* for default implementations It might be possible to have .* automatically calling the default implementation of a trait (defined with implDefault from @straits/utils) in case one were available. That's not the current behavior.","title":"Straits syntax"},{"location":"syntax/#straits-syntax","text":"Straits introduces the .* operator and use traits statement.","title":"Straits syntax"},{"location":"syntax/#use-traits-statement","text":"1 use traits * from traitSet ; The use traits statement is used to specify which traits are available. use traits * from traitSet; enables all the traits defined in traitSet . It applies to the current scopes and all subscopes.","title":"use traits statement"},{"location":"syntax/#operator","text":"1 2 obj . * trait obj . * trait = ...; The .* operator is used to access a trait of an object. obj.*trait will access the trait named trait on obj . Exactly one trait named trait must be available (thanks to an use traits statement) in the scope where it's used: if none, or multiple different ones are available, an exception will be thrown. If .* is used to assign a trait, such trait (i.e. symbol property) will be not-enumerable. .* requires a trait name to be statically used. A symbol variable cannot be used as a trait: it can be accessed using [] . .* won't work on null or undefined , since . operator can't work on them either. @straits/utils offers some utility function to work with them: an asFreeFunction() function to obtain a free function wrapping a trait. Such free function could have a default behavior for objects that don't implement the trait, which can be installed with implDefault() .","title":".* operator"},{"location":"syntax/#straitsbabel","text":"@straits/babel can be used to transpile the traits syntax into standard JavaScript.","title":"@straits/babel"},{"location":"syntax/#proposed-enhancements","text":"","title":"Proposed enhancements"},{"location":"syntax/#use-specific-traits","text":"The use traits statement could support, besides * , a list of trait names: 1 2 use traits x , y from traitSet1 ; use traits z , * from traitSet2 ; This would cause looking for the explicitly listed traits in specific trait sets with higher priority: if different traits with the same name were enabled by some use traits * statements, those would be ignored and no error would be thrown. @straits/babel doesn't support such syntax yet.","title":"Use specific traits"},{"location":"syntax/#for-default-implementations","text":"It might be possible to have .* automatically calling the default implementation of a trait (defined with implDefault from @straits/utils) in case one were available. That's not the current behavior.","title":".* for default implementations"}]}